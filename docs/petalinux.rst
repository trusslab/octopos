=======================
OctopOS SecHw Petalinux
=======================

:Author: - Zephyr Yao <z.yao@uci.edu>

This guide covers the Petalinux setup for OctopOS Secure Hardware. 

Software versions
=================
Ubuntu 16.04
Xilinx tools 2019.1 (mixing different versions will not work)

Install Petalinux Dependencies
==============================
Please refer to UG1144(v2019.1) for dependencies and installation guide.
https://www.xilinx.com/support/documentation/sw_manuals/xilinx2019_1/ug1144-petalinux-tools-reference-guide.pdf

Errata: 
On Page 11, correct dependencies:
sudo apt-get install -y gcc git make net-tools libncurses5-dev tftpd zlib1g-dev libssl-dev flex bison libselinux1 gnupg wget diffstat chrpath socat xterm autoconf libtool tar unzip texinfo zlib1g-dev gcc-multilib build-essential zlib1g:i386 screen pax gzip gawk

Install Petalinux
=================
On page 12, it says,
"Note: Do not change the installer permissions to CHMOD 775 as it can cause BitBake errors."

"chmod 764" works.

add source <path-to-installed-PetaLinux>/settings.sh to ~/.bashrc

Create Petalinux Project
========================
Although OctopOS contains an established Petalinux project, if you would like to create a new Petalinux project from the scratch, please see below.

The correct Petalinux bsp is, xilinx-zcu102-v2019.1-final.bsp. Do not use other revisions.

A sample create command,
petalinux-create --type project -s <Path_to_BSP> --name <Proj_Name>

Configurations
==============
After Vivado has done generating bitstreams, click File -> Export -> Export Hardware. The hdf file is in <Vivado_Proj_Path>/<Proj_Name.sdk>/\*.hdf.

Re-config every time when the hardware design changes. Note that the --get-hw-description takes the path of the directory that contains a hdf file, not the path to a hdf file.
petalinux-config --get-hw-description=<Path_to_sdk>

Memory Conflict:
Without proper memory arrangement, Petalinux running on Cortex A53 can easily mess up with the other processer's DDR memory. The Petalinux system memory base address and size can be configurated during the config, under "Subsystem AUTO Hardware Settings" -> "Memory Settings".

To set the address for R5, goto the R5 application project in the SDK. Open lscript.ld, and change the address for psu_r5_ddr_0_MEM_0.

Our Microblaze soft core access the DDR memory through HP0. In Vivado's address editor, find the core, and then map zynq_ultra_ps_e_0's HP0_DDR_LOW interface. The Offset Adress and range controls the actual DDR memory accessible by the soft core. 

It is difficult to limit the memory range for DDR controller (generated through MIG). Please see the questions below for the mapping details.
https://www.xilinx.com/support/answers/51790.html
https://forums.xilinx.com/t5/Memory-Interfaces-and-NoC/How-to-map-the-AXI4-address-to-the-ddr4-memory-address/td-p/954407

UART Conflict:
To set the UART used by R5, goto the R5 BSP settings in the SDK. You can config stdout/stdin there.
Petalinux's UART setting is in "Subsystem AUTO Hardware Settings". However, this is not enough to prevent linux from accessing the other UART used by R5. Add the lines below to ./project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dtsi
&uart1 {
	status="disabled";
};

Interrupt Route:
Petalinux generates interrupt configurations for lines connected to pl_ps_irq0 and pl_ps_irq1 automatically. Therefore, R5 will no longer have access to these interrupts when Linux is booted.

To route an interrupt to R5, add the line below to ./project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dtsi
/delete-node/ &<INTR_LINE_NAME0>

Manually removing an interrupt in ./components/plnx_workspace/device_tree/pl.dtsi will not work because the file is regenerated right before petalinux-build.

Build Petalinux
===============
Run, petalinux-build. 
Note that we will not be using the FSBL and PMU firmware built by this command, since we have made modifications to their source codes in the SDK. 

The build will take a while.

Encoding BRAM contents into bitstream
=====================================
These are the memory contents that boots a soft core. Please use our build.sh to encode BRAM contents into a final bitstream. We use the updatemem command, which reads the hardware design memory mapping (mmi file), and incrementally add one elf file to one bit file. There will be n runs if there are n individual BRAM contents. One run's output (bit file) must be the input file for the next run.

This process will take a while.

Create boot image
=================
We use SDK's bootgen gui to create image. Our boot image configurations is saved to BOOT.bif. The script hard codes the paths to our PMU, FSBL, R5, PL bit stream, uboot and linux image. The later two are generated by petalinux-build. 

The bootgen commands is visible in the SDK log. If you prefer using command lines, simply save these commands.

Run Petalinux
=============
cp image.ub (generated by petalinux-build) and BOOT.bin (generated by bootgen) into a FAT32 SD card. Make sure the boot mode switches are set to SD mode (1000).

If serial input is not working, disable Hardware Flow Control prior to powering the board.
